<!DOCTYPE html>
<html lang="en">
    <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Code Search</title>
            <style>
                body {
                    font-family: Arial, sans-serif;
                    margin: 20px;
                }
                .container {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 20px;
                }
                .ans {
                    width: 300px;
                    overflow: auto;
                    padding: 10px;
                    background-color: #f4f4f4;
                    border-radius: 5px;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
                    display: none;
                }
                .ans h4 {
                    margin-top: 0;
                    font-size: 18px;
                }
                pre {
                    background-color: #eaeaea;
                    padding: 10px;
                    border-radius: 5px;
                    white-space: pre-wrap;
                    word-wrap: break-word;
                }
                #search {
                    width: 300px;
                    padding: 10px;
                    margin-bottom: 20px;
                    border-radius: 5px;
                    border: 1px solid #ccc;
                }
            </style>
        </head>
<body>
    <input type="text" id="search" placeholder="Search for an algorithm..." onkeyup="searchCode()">

    <div class="container">
        <div class="ans" id="merge-sort">
            <h4>MERGE SORT</h4>
            <pre><code>
                public class MergeSort { 
            public static void main(String[] args) { 
                int[] arr = {12, 11, 13, 5, 6, 7}; 
                System.out.println("Given Array:"); 
                printArray(arr); 
                MergeSort ob = new MergeSort(); 
                ob.sort(arr, 0, arr.length - 1); 
                System.out.println("\nSorted array:"); 
                printArray(arr); 
            } 
        
            void merge(int arr[], int l, int m, int r) { 
                int n1 = m - l + 1; 
                int n2 = r - m; 
                int L[] = new int[n1]; 
                int R[] = new int[n2]; 
                System.arraycopy(arr, l, L, 0, n1); 
                System.arraycopy(arr, m + 1, R, 0, n2); 
                int i = 0, j = 0; 
                int k = l; 
                while (i < n1 && j < n2) { 
                    if (L[i] <= R[j]) { 
                        arr[k] = L[i]; 
                        i++; 
                    } else { 
                        arr[k] = R[j]; 
                        j++; 
                    } 
                    k++; 
                } 
                while (i < n1) { 
                    arr[k] = L[i]; 
                    i++; 
                    k++; 
                } 
                while (j < n2) { 
                    arr[k] = R[j]; 
                    j++; 
                    k++; 
                }
            } 
        
            void sort(int arr[], int l, int r) { 
                if (l < r) { 
                    int m = (l + r) / 2; 
                    sort(arr, l, m); 
                    sort(arr, m + 1, r); 
                    merge(arr, l, m, r); 
                } 
            } 
        
            static void printArray(int arr[]) { 
                for (int j : arr) { 
                    System.out.print(j + " "); 
                } 
                System.out.println(); 
            } 
        }
            </code></pre>
        </div>
        <div class="ans" id="QuickSort">
            <h4>
                QUICK SORT
            </h4>
            <pre><code>
            public class QuickSort { 
            public static void main(String[] args) { 
            int[] arr = {10, 7, 8, 9, 1, 5}; 
            int n = arr.length; 
            QuickSort ob = new QuickSort(); 
            ob.sort(arr, 0, n - 1); 
            System.out.println("Sorted array:"); 
            printArray(arr); 
            } 
            int partition(int arr[], int low, int high) { 
            int pivot = arr[high]; 
        int i = (low - 1); 
            for (int j = low; j < high; j++) { 
            if (arr[j] <= pivot) { 
                    i++; 
                        int temp = arr[i]; 
            arr[i] = arr[j]; 
            arr[j] = temp; 
            } } 
            int temp = arr[i + 1]; 
            arr[i + 1] = arr[high]; 
        arr[high] = temp; 
            return i + 1; 
            } 
            void sort(int arr[], int low, int high) { 
            if (low < high) { 
            int pi = partition(arr, low, high); 
            sort(arr, low, pi - 1); 
        sort(arr, pi + 1, high); 
            } } 
            static void printArray(int arr[]) { 
            for (int j : arr) System.out.print(j + " "); 
            System.out.println(); 
            }}
            </code></pre>
        </div>
        <div class="ans" id="fknapsack">
            <h4>F-KNAPSACK</h4>
            <pre><code>
import java.util.*; 
class Item { 
double weight; 
double profit; 
double weightProfitRatio; 
public Item(double weight, double profit) { 
this.weight = weight; 
this.profit = profit; 
this.weightProfitRatio = profit / weight; 
} 
} 
public class fknapsack { 
public static void main(String[] args) { 
Scanner sc = new Scanner(System.in); 
System.out.println("Enter number of objects: "); 
int objectCount = sc.nextInt(); 
Item[] objects = new Item[objectCount]; 
System.out.println("Enter capacity of Knapsack: "); 
double capacity = sc.nextDouble(); 
System.out.println("Enter the object details:"); 
for (int i = 0; i < objectCount; i++) { 
System.out.println("Enter weight: "); 
double weight = sc.nextDouble(); 
System.out.println("Enter profit: "); 
double profit = sc.nextDouble(); 
objects[i] = new Item(weight, profit); 
} 
double maxProfit = fractionalKnapsack(objects, capacity); 
System.out.println("Maximum profit: " + maxProfit); 
    } 
static double fractionalKnapsack(Item[] items,double capacity) 
    {
Arrays.sort(items, (a, b) -> 
Double.compare(b.weightProfitRatio, a.weightProfitRatio)); 
        double totalProfit = 0; 
        for (Item i : items) { 
            if (capacity == 0) break; 
            if (i.weight <= capacity) { 
            totalProfit += i.profit; 
            capacity -= i.weight; 
            } else { 
        totalProfit += i.profit * (capacity / i.weight); 
                capacity = 0;  
            }  } 
        return totalProfit; 
}}
            </code></pre>
        </div>
        <div class="ans" id="0/1">
            <h4>0/1 KNAPSACK</h4>
            <pre><code>
import java.util.*; 
class Item { 
int weight;  int profit; 
public Item(int weight, int profit) { 
        this.weight = weight; 
    this.profit = profit; 
        }} 
        public class KnapSack { 
        public static void main(String args[]) { 
        Scanner sc = new Scanner(System.in); 
        System.out.println("Enter number of objects: "); 
        int objectCount = sc.nextInt(); 
        Item[] objects = new Item[objectCount]; 
    System.out.println("Enter capacity of Knapsack: "); 
            int capacity = sc.nextInt(); 
System.out.println("Enter the object details:"); 
        for (int i = 0; i < objectCount; i++) { 
        System.out.println("Enter weight: "); 
        int weight = sc.nextInt(); 
        System.out.println("Enter profit: "); 
        int profit = sc.nextInt(); 
        objects[i] = new Item(weight, profit); 
        } 
        int maxProfit = Knapsackop(objects, capacity); 
        System.out.println("Maximum profit: " + maxProfit); 
        } 
        public static int Knapsackop(Item[] item,int capacity){ 
        int n=item.length; 
        int[] dp=new int[capacity+1]; 
            for(int i=0;i<n;i++){ 
    for(int w=capacity;w>=item[i].weight;w--){ 
    dp[w]=Math.max(dp[w],dp[w-item[i].weight]+item[i].profit); 
                }  } 
    return dp[capacity];    }}
            </code></pre>
        </div>
    </div>
    <div class="ans" id="prims">
        <h4>PRIMS</h4>
        <pre><code>
            import java.util.Scanner; 
            public class PrimsMST { 
            public static void primMST(int[][] graph) { 
            int n = graph.length; 
            boolean[] selected = new boolean[n]; 
            int[] minEdge = new int[n]; 
            int[] parent = new int[n]; 
            for (int i = 0; i < n; i++) { 
            minEdge[i] = Integer.MAX_VALUE; 
            parent[i] = -1; 
            } 
            minEdge[0] = 0; 
for (int count = 0; count < n - 1; count++) { 
int u = minVertex(minEdge, selected); 
            selected[u] = true; 
    for (int v = 0; v < n; v++) { 
if (graph[u][v] != 0 && !selected[v] && graph[u][v] < minEdge[v]) { 
            parent[v] = u; 
            minEdge[v] = graph[u][v]; 
            } }  } 
            System.out.println("Edge \tWeight"); 
            for (int i = 1; i < n; i++) { 
System.out.println(parent[i] + " - " + i + "\t" + 
graph[i][parent[i]]); 
            } } 
private static int minVertex(int[] minEdge, boolean[] selected) { 
int min = Integer.MAX_VALUE, minIndex = -1; 
 for (int i = 0; i < minEdge.length; i++) { 
 if (!selected[i] && minEdge[i] < min) { 
            min = minEdge[i]; 
            minIndex = i; 
            } } 
            return minIndex; 
            } 
    public static void main(String[] args) { 
      Scanner scanner = new Scanner(System.in); 
    System.out.print("Enter the number of vertices: "); 
            int n = scanner.nextInt(); 
            int[][] graph = new int[n][n]; 
System.out.println("Enter the adjacency matrix:"); 
            for (int i = 0; i < n; i++) { 
            for (int j = 0; j < n; j++) { 
            graph[i][j] = scanner.nextInt(); 
            }  
            } 
            primMST(graph); 
            }}
        </code></pre>
    </div>
    <div class="ans" id="krushkal">
        <h4>KRUSHKAL</h4>
        <pre><code>
            import java.util.Arrays; 
            import java.util.Scanner; 
            class Edge implements Comparable<Edge> { 
            int src, dest, weight; 
            public int compareTo(Edge other) { 
            return this.weight - other.weight; 
            }} 
            public class KruskalsMST { 
            public static void kruskalMST(int[][] graph) { 
            int n = graph.length; 
            Edge[] edges = new Edge[n * (n - 1) / 2]; 
            int edgeIndex = 0; 
            for (int i = 0; i < n; i++) { 
            for (int j = i + 1; j < n; j++) { 
            if (graph[i][j] != 0) { 
            edges[edgeIndex++] = new Edge(); 
            edges[edgeIndex - 1].src = i; 
            edges[edgeIndex - 1].dest = j; 
            edges[edgeIndex - 1].weight = graph[i][j]; 
            }}  } 
            Arrays.sort(edges); 
            int[] parent = new int[n]; 
            for (int i = 0; i < n; i++) parent[i] = i; 
            System.out.println("Edge \tWeight"); 
            int e = 0; 
            for (Edge edge : edges) { 
            if (e == n - 1) break; 
            int srcRoot = find(parent, edge.src); 
            int destRoot = find(parent, edge.dest); 
            if (srcRoot != destRoot) { 
            System.out.println(edge.src + " - " + edge.dest + "\t" + edge.weight); 
            parent[srcRoot] = destRoot; 
            e++; 
            }} } 
            private static int find(int[] parent, int i) { 
            if (parent[i] != i) parent[i] = find(parent, parent[i]); 
            return parent[i]; 
            } 
            public static void main(String[] args) { 
            Scanner scanner = new Scanner(System.in); 
            System.out.print("Enter the number of vertices: "); 
            int n = scanner.nextInt(); 
            int[][] graph = new int[n][n]; 
            System.out.println("Enter the adjacency matrix:"); 
            for (int i = 0; i < n; i++) { 
            for (int j = 0; j < n; j++) { 
            graph[i][j] = scanner.nextInt(); 
            }} 
            kruskalMST(graph); 
            }}
        </code></pre>
    </div>
    <div class="ans" id="tsp">
        <h4>TSP</h4>
        <pre><code>
            import java.util.Scanner; 
public class TravelingSalesperson { 
private static final int INF = Integer.MAX_VALUE / 2; 
private int n; 
private int[][] dist; 
private int[][] dp; 
public TravelingSalesperson(int n, int[][] dist) { 
this.n = n; 
this.dist = dist; 
this.dp = new int[1 << n][n]; 
for (int i = 0; i < (1 << n); i++) { 
for (int j = 0; j < n; j++) { 
dp[i][j] = -1;}}} 
private int tsp(int mask, int pos) { 
if (mask == (1 << n) - 1) { 
return dist[pos][0]; 
} 
if (dp[mask][pos] != -1) { 
return dp[mask][pos]; 
} 
int ans = INF; 
for (int city = 0; city < n; city++) { 
if ((mask & (1 << city)) == 0) { 
int newAns = dist[pos][city] + tsp(mask | (1 << city), city); 
ans = Math.min(ans, newAns); 
} } 
return dp[mask][pos] = ans;  } 
public int findMinCost() { 
return tsp(1, 0);} 
public static void main(String[] args) { 
Scanner scanner = new Scanner(System.in); 
System.out.print("Enter number of cities: "); 
int n = scanner.nextInt(); 
int[][] dist = new int[n][n]; 
System.out.println("Enter distance matrix:"); 
for (int i = 0; i < n; i++) { 
for (int j = 0; j < n; j++) { 
dist[i][j] = scanner.nextInt();  }   } 
TravelingSalesperson tsp = new TravelingSalesperson(n, dist); 
System.out.println("Minimum travel cost: " + tsp.findMinCost());}} 
        </code></pre>
    </div>
    <div class="ans" id="job">
        <h4>JOB SEQUENCING</h4>
        <pre><code>
            import java.util.Arrays; 
            import java.util.Scanner; 
            class Job { 
            int id, deadline, profit; 
            Job(int id, int deadline, int profit) { 
            this.id = id; 
            this.deadline = deadline; 
            this.profit = profit; 
            }} 
            public class JobSequencing { 
            public static void jobSequencing(Job[] jobs, int n) { 
            Arrays.sort(jobs, (a, b) -> b.profit - a.profit); 
            int[] result = new int[n]; 
            boolean[] slot = new boolean[n]; 
            for (Job job : jobs) { 
            for (int j = Math.min(n - 1, job.deadline - 1); j >= 0; j--) { 
            if (!slot[j]) { 
            slot[j] = true; 
            result[j] = job.id; 
            break; 
            }}} 
            System.out.println("Job sequence for maximum profit:"); 
            for (int id : result) { 
            if (id != 0) System.out.print("Job " + id + " "); 
            }} 
            public static void main(String[] args) { 
            Scanner scanner = new Scanner(System.in); 
            System.out.print("Enter the number of jobs: "); 
            int n = scanner.nextInt(); 
            Job[] jobs = new Job[n]; 
            for (int i = 0; i < n; i++) { 
            System.out.print("Enter job ID, deadline, and profit for job " + (i + 1) + ": "); 
            int id = scanner.nextInt(); 
            int deadline = scanner.nextInt(); 
            int profit = scanner.nextInt(); 
            jobs[i] = new Job(id, deadline, profit); 
            } 
            jobSequencing(jobs, n);}} 

        </code></pre>
    </div>
    <div class="ans" id="single">
        <h4>SINGLE SOURCE PATH</h4>
        <pre><code>
import java.util.Scanner; 
import java.util.Arrays; 
public class Dijkstra { 
public static void dijkstra(int[][] graph, int source) { 
int n = graph.length; 
int[] distance = new int[n]; 
boolean[] visited = new boolean[n]; 
Arrays.fill(distance, Integer.MAX_VALUE); 
distance[source] = 0; 
for (int i = 0; i < n - 1; i++) { 
int u = minDistance(distance, visited); 
visited[u] = true; 
for (int v = 0; v < n; v++) { 
if (!visited[v] && graph[u][v] != 0 && distance[u] != Integer.MAX_VALUE && 
distance[u] + graph[u][v] < distance[v]) { 
distance[v] = distance[u] + graph[u][v]; 
}}} 
System.out.println("Vertex \tDistance from Source"); 
for (int i = 0; i < n; i++) { 
System.out.println(i + " \t\t " + distance[i]); 
}} 
private static int minDistance(int[] distance, boolean[] visited) { 
int min = Integer.MAX_VALUE, minIndex = -1; 
for (int i = 0; i < distance.length; i++) { 
if (!visited[i] && distance[i] < min) { 
min = distance[i]; 
minIndex = i; 
}  
 } 
return minIndex;} 
public static void main(String[] args) { 
Scanner scanner = new Scanner(System.in); 
System.out.print("Enter the number of vertices: "); 
int n = scanner.nextInt(); 
int[][] graph = new int[n][n]; 
System.out.println("Enter the adjacency matrix:"); 
for (int i = 0; i < n; i++) { 
for (int j = 0; j < n; j++) { 
graph[i][j] = scanner.nextInt(); 
}} 
System.out.print("Enter the source vertex: "); 
int source = scanner.nextInt(); 
dijkstra(graph, source); 
}} 
 
        </code></pre>
    </div>
    <div class="ans">
        <h4>ALL PAIRS</h4>
        <pre><code>
            import java.util.Arrays; 
            public class AllPairsShortestPath { 
            static final int INF = Integer.MAX_VALUE; 
            public static void floydWarshall(int[][] graph) { 
            int V = graph.length; 
                    int[][] dist = new int[V][V]; 
                    for (int i = 0; i < V; i++) { 
                        for (int j = 0; j < V; j++) { 
                            if (i == j) { 
                                dist[i][j] = 0;  
                            } else if (graph[i][j] != 0) { 
                                dist[i][j] = graph[i][j];  
                                dist[i][j] = INF;  
                            }} } 
        for (int k = 0; k < V; k++) { 
            for (int i = 0; i < V; i++) { 
            for (int j = 0; j < V; j++) { 
            if (dist[i][k] != INF && dist[k][j] != INF) { 
            dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]); 
                                }}} } 
                    printSolution(dist); 
                } 
            static void printSolution(int[][] dist) { 
                    int V = dist.length; 
System.out.println("Shortest distances between every pair of vertices:"); 
    for (int i = 0; i < V; i++) { 
     for (int j = 0; j < V; j++) { 
  if (dist[i][j] == INF) { 
      System.out.print("INF "); 
     } else { 
            System.out.print(dist[i][j] + " "); 
            } } 
      System.out.println(); 
         }} 
    public static void main(String[] args) { 
int[][] graph = {  {0, 3, INF, INF, INF}, 
                   {2, 0, INF, 1, INF}, 
                    {INF, 7, 0, INF, 2}, 
                    {6, INF, INF, 0, 3}, 
                    {INF, INF, 1, INF, 0} 
            }; 
            floydWarshall(graph);} 
        </code></pre>
    </div>
    <div class="ans" id="nqueens">
        <h4>N QUEENS</h4>
        <pre><code>
public class NQueens { 
private int n; 
private int[][] board; 
    public NQueens(int n) { 
        this.n = n; 
      this.board = new int[n][n];} 
     public boolean solveNQueens() { 
      if (placeQueens(0)) { 
      printSolution(); 
    return true; 
        } else { 
       System.out.println("No solution exists."); 
           return false;}} 
                private boolean placeQueens(int row) { 
       if (row == n) return true; 
    for (int col = 0; col < n; col++) { 
    if (isSafe(row, col)) { 
                board[row][col] = 1; 
         if (placeQueens(row + 1)) return true; 
                board[row][col] = 0;}} 
                return false; 
                } 
                private boolean isSafe(int row, int col) { 
     for (int i = 0; i < row; i++) if (board[i][col] == 1) return false; 
                for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) if (board[i][j] == 1) return false; 
   for (int i = row, j = col; i >= 0 && j < n; i--, j++) if (board[i][j] == 1) return false; 
                return true; 
                } 
                private void printSolution() { 
                for (int[] row : board) { 
                for (int cell : row) System.out.print(cell + " "); 
                System.out.println();}} 
                public static void main(String[] args) { 
                int n = 4; 
                NQueens nQueens = new NQueens(n); 
                nQueens.solveNQueens();}}
        </code></pre>
    </div>
    <div class="ans" id="SumOfSubsets">
        <h4>SUM OF SUBSETS</h4>
        <pre><code>
            import java.util.ArrayList; 
            import java.util.List; 
            public class SumOfSubsets { 
            public static void findSubsets(int[] set, int targetSum) { 
            List<Integer> subset = new ArrayList<>(); 
            findSubsetsRecursive(set, 0, 0, targetSum, subset);} 
            private static void findSubsetsRecursive(int[] set, int index, int currentSum, int targetSum, List<Integer> subset) { 
            if (currentSum == targetSum) { 
            System.out.println(subset); 
            Return;    } 
            if (index >= set.length || currentSum > targetSum) return; 
            subset.add(set[index]); 
            findSubsetsRecursive(set, index + 1, currentSum + set[index], targetSum, subset); 
            subset.remove(subset.size() - 1); 
            findSubsetsRecursive(set, index + 1, currentSum, targetSum, subset);} 
            public static void main(String[] args) { 
            int[] set = {3, 34, 4, 12, 5, 2}; 
            int targetSum = 9; 
            findSubsets(set, targetSum);}}
        </code></pre>
    </div>
    <div class="ans" id="graphColoring">
        <h4>GRAPH COLORING</h4>
        <pre><code>
            public class GraphColoring { 
                private int[][] graph; private int[] colors;  private int numColors; 
                public GraphColoring(int[][] graph, int numColors) { 
                this.graph = graph; 
                this.numColors = numColors; 
                this.colors = new int[graph.length];} 
                public boolean solveColoring() { 
                if (colorGraph(0)) { 
                printSolution(); 
                return true; 
                } else { 
                System.out.println("No solution exists."); 
                return false;}} 
                private boolean colorGraph(int vertex) { 
                if (vertex == graph.length) return true; 
                for (int color = 1; color <= numColors; color++) { 
                if (isSafe(vertex, color)) { 
                colors[vertex] = color; 
                if (colorGraph(vertex + 1)) return true; 
                colors[vertex] = 0;}  } 
                return false;} 
                private boolean isSafe(int vertex, int color) { 
                for (int i = 0; i < graph.length; i++) { 
                if (graph[vertex][i] == 1 && colors[i] == color) return false;} 
                return true;} 
                private void printSolution() { 
                for (int color : colors) { 
                System.out.print(color + " ");   } 
                System.out.println();} 
                public static void main(String[] args) { 
                int[][] graph = { 
                {0, 1, 1, 1}, 
                {1, 0, 1, 0}, 
                {1, 1, 0, 1}, 
                {1, 0, 1, 0} 
                }; 
                int numColors = 3; 
                GraphColoring graphColoring = new GraphColoring(graph, numColors); 
                graphColoring.solveColoring();}} 
        </code></pre>
    </div>
    <div class="ans" id="hamiltonianCycle">
        <h4>HAMILTONIAN CYCLE</h4>
        <pre><code>
public class HamiltonianCycle { 
    private int[][] graph; private int[] path; 
    public HamiltonianCycle(int[][] graph) { 
        this.graph = graph; 
        this.path = new int[graph.length]; 
        for (int i = 0; i < path.length; i++) path[i] = -1; 
        path[0] = 0;} 
        public boolean solveHamiltonianCycle() { 
        if (findHamiltonianCycle(1)) { 
        printSolution(); 
            return true; 
                    } else { 
    System.out.println("No solution exists."); 
        return false;}} 
private boolean findHamiltonianCycle(int pos) { 
if (pos == graph.length) { 
return graph[path[pos - 1]][path[0]] == 1; } 
    for (int v = 1; v < graph.length; v++) { 
        if (isSafe(v, pos)) { 
            path[pos] = v; 
    if (findHamiltonianCycle(pos + 1)) return true; 
                            path[pos] = -1;} } 
                    return false;} 
                private boolean isSafe(int v, int pos) { 
            if (graph[path[pos - 1]][v] == 0) return false; 
            for (int i = 0; i < pos; i++) { 
            if (path[i] == v) return false;} 
            return true; } 
            private void printSolution() { 
            for (int vertex : path) { 
            System.out.print(vertex + " "); } 
            System.out.println(path[0]); } 
            public static void main(String[] args) { 
            int[][] graph = { 
            {0, 1, 0, 1, 0}, 
            {1, 0, 1, 1, 1}, 
            {0, 1, 0, 0, 1}, 
            {1, 1, 0, 0, 1}, 
            {0, 1, 1, 1, 0} 
            }; 
            HamiltonianCycle hamiltonianCycle = new HamiltonianCycle(graph); 
            hamiltonianCycle.solveHamiltonianCycle();}}
        </code></pre>
    </div>
    <div class="ans" id="avl-tree">
        <h4> AVL TREE</h4>
        <pre><code>
            class AVLTreeNode { 
                int key, height; 
                AVLTreeNode left, right; 
                AVLTreeNode(int key) { 
                this.key = key; 
                this.height = 1;}} 
                public class AVLTree { 
                private AVLTreeNode root; 
                private int height(AVLTreeNode node) { 
                return node == null ? 0 : node.height; } 
                private int getBalance(AVLTreeNode node) { 
                return node == null ? 0 : height(node.left) - height(node.right);} 
                private AVLTreeNode rotateRight(AVLTreeNode y) { 
                AVLTreeNode x = y.left; 
                AVLTreeNode T2 = x.right; 
                x.right = y; 
                y.left = T2; 
                y.height = Math.max(height(y.left), height(y.right)) + 1; 
                x.height = Math.max(height(x.left), height(x.right)) + 1; 
                return x;  } 
                private AVLTreeNode rotateLeft(AVLTreeNode x) { 
                AVLTreeNode y = x.right; 
                AVLTreeNode T2 = y.left; 
                y.left = x; 
                x.right = T2; 
                x.height = Math.max(height(x.left), height(x.right)) + 1; 
                y.height = Math.max(height(y.left), height(y.right)) + 1; 
                return y;} 
                private AVLTreeNode insert(AVLTreeNode node, int key) { 
                if (node == null) return new AVLTreeNode(key); 
                if (key < node.key) node.left = insert(node.left, key); 
                else if (key > node.key) node.right = insert(node.right, key); 
                else return node; 
                node.height = Math.max(height(node.left), height(node.right)) + 1; 
                int balance = getBalance(node); 
                if (balance > 1 && key < node.left.key) return rotateRight(node); 
                if (balance < -1 && key > node.right.key) return rotateLeft(node); 
                if (balance > 1 && key > node.left.key) { 
                node.left = rotateLeft(node.left); 
                return rotateRight(node); } 
                if (balance < -1 && key < node.right.key) { 
                node.right = rotateRight(node.right); 
                return rotateLeft(node);} 
                return node;} 
                private AVLTreeNode delete(AVLTreeNode root, int key) { 
                if (root == null) return root; 
                if (key < root.key) root.left = delete(root.left, key); 
                else if (key > root.key) root.right = delete(root.right, key); 
                else { 
                if ((root.left == null) || (root.right == null)) { 
                AVLTreeNode temp = root.left != null ? root.left : root.right; 
                root = temp == null ? null : temp; 
                } else { 
                AVLTreeNode temp = minValueNode(root.right); 
                root.key = temp.key; 
                root.right = delete(root.right, temp.key);}} 
                if (root == null) return root; 
                root.height = Math.max(height(root.left), height(root.right)) + 1; 
                int balance = getBalance(root); 
                if (balance > 1 && getBalance(root.left) >= 0) return rotateRight(root); 
                if (balance > 1 && getBalance(root.left) < 0) { 
                root.left = rotateLeft(root.left); 
                return rotateRight(root);  } 
                if (balance < -1 && getBalance(root.right) <= 0) return rotateLeft(root); 
                if (balance < -1 && getBalance(root.right) > 0) { 
                root.right = rotateRight(root.right); 
                return rotateLeft(root);} 
                return root;   } 
                private AVLTreeNode minValueNode(AVLTreeNode node) { 
                AVLTreeNode current = node; 
                while (current.left != null) current = current.left; 
                return current;} 
                public void insert(int key) { 
                root = insert(root, key);} 
                public void delete(int key) { 
                root = delete(root, key);} 
                public void inorderTraversal(AVLTreeNode node) { 
                if (node != null) { 
                inorderTraversal(node.left); 
                System.out.print(node.key + " "); 
                inorderTraversal(node.right);  } } 
                public void printInorder() { 
                inorderTraversal(root); 
                System.out.println();} 
                public static void main(String[] args) { 
                AVLTree tree = new AVLTree(); 
                        tree.insert(10); 
                        tree.insert(20); 
                        tree.insert(30); 
                        tree.insert(40); 
                        tree.insert(50); 
                        tree.insert(25); 
                        tree.printInorder(); 
                        tree.delete(10); 
                        tree.printInorder();}}
        </code></pre>
    </div>
    <div class="ans" id="b-tree">
        <h4> B TREE</h4>
        <pre><code>
            class BTreeNode { 
                int[] keys;int degree; 
                BTreeNode[] children; 
                int numKeys; boolean isLeaf; 
                public BTreeNode(int degree, boolean isLeaf) { 
                this.degree = degree; 
                this.isLeaf = isLeaf; 
                this.keys = new int[2 * degree - 1]; 
                this.children = new BTreeNode[2 * degree]; 
                this.numKeys = 0;} 
                public void traverse() { 
                int i; 
                for (i = 0; i < numKeys; i++) { 
                if (!isLeaf) children[i].traverse(); 
                System.out.print(keys[i] + " "); } 
                if (!isLeaf) children[i].traverse(); 
                }public BTreeNode search(int key) { 
                int i = 0; 
                while (i < numKeys && key > keys[i]) i++; 
                if (keys[i] == key) return this; 
                if (isLeaf) return null; 
                return children[i].search(key); 
                }public void insertNonFull(int key) { 
                int i = numKeys - 1; 
                if (isLeaf) { 
                while (i >= 0 && keys[i] > key) { 
                keys[i + 1] = keys[i]; 
                i--; 
                } 
                keys[i + 1] = key; 
                numKeys++; 
                } else { 
                while (i >= 0 && keys[i] > key) i--; 
                if (children[i + 1].numKeys == 2 * degree - 1) { 
                splitChild(i + 1, children[i + 1]); 
                if (keys[i + 1] < key) i++; 
                } 
                children[i + 1].insertNonFull(key); }} 
                public void splitChild(int i, BTreeNode y) { 
                BTreeNode z = new BTreeNode(y.degree, y.isLeaf); 
                z.numKeys = degree - 1; 
                for (int j = 0; j < degree - 1; j++) z.keys[j] = y.keys[j + degree]; 
                if (!y.isLeaf) { 
                for (int j = 0; j < degree; j++) z.children[j] = y.children[j + degree]; 
                } 
                y.numKeys = degree - 1; 
                for (int j = numKeys; j >= i + 1; j--) children[j + 1] = children[j]; 
                children[i + 1] = z; 
                for (int j = numKeys - 1; j >= i; j--) keys[j + 1] = keys[j]; 
                keys[i] = y.keys[degree - 1]; 
                numKeys++; }} 
                public class BTree { 
                private BTreeNode root; 
                private int degree; 
                public BTree(int degree) { 
                this.root = null; 
                this.degree = degree;} 
                public void traverse() { 
                if (root != null) root.traverse();} 
                public BTreeNode search(int key) { 
                return root == null ? null : root.search(key);} 
                public void insert(int key) { 
                if (root == null) { 
                root = new BTreeNode(degree, true); 
                root.keys[0] = key;      
                } else { 
                root.numKeys = 1; 
                if (root.numKeys == 2 * degree - 1) { 
                BTreeNode s = new BTreeNode(degree, false); 
                s.children[0] = root; 
                s.splitChild(0, root);       
                int i = s.keys[0] < key ? 1 : 0; 
                s.children[i].insertNonFull(key); 
                root = s; 
                } else { 
                root.insertNonFull(key);}}} 
                public static void main(String[] args) { 
                BTree bTree = new BTree(3); 
                bTree.insert(10); 
                bTree.insert(20); 
                bTree.insert(5); 
                bTree.insert(6); 
                bTree.insert(12); 
                bTree.insert(30); 
                bTree.insert(7); 
                bTree.insert(17); 
                bTree.traverse(); 
                }}
        </code></pre>
    </div>
    </div>
    <script>
        function searchCode() {
            var input = document.getElementById('search').value.toLowerCase();
            var allCodes = document.querySelectorAll('.ans');

            allCodes.forEach(function(codeBlock) {
                var heading = codeBlock.querySelector('h4').textContent.toLowerCase();
                if (heading.includes(input)) {
                    codeBlock.style.display = 'block';  // Show the matching code block
                } else {
                    codeBlock.style.display = 'none';   // Hide the non-matching code block
                }
            });
        }
    </script>
</body>
</html>
